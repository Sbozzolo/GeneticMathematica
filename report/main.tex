%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Journal Article
% LaTeX Template
% Version 1.4 (15/5/16)
%
% This template has been downloaded from:
% http://www.LaTeXTemplates.com
%
% Original author:
% Frits Wenneker (http://www.howtotex.com) with extensive modifications by
% Vel (vel@LaTeXTemplates.com)
%
% License:
% CC BY-NC-SA 3.0 (http://creativecommons.org/licenses/by-nc-sa/3.0/)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%----------------------------------------------------------------------------------------
%	PACKAGES AND OTHER DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------

\documentclass[italian,twoside,twocolumn]{article}

\usepackage{blindtext} % Package to generate dummy text throughout this template 

\usepackage[utf8]{inputenc}

\usepackage[sc]{mathpazo} % Use the Palatino font
\usepackage[T1]{fontenc} % Use 8-bit encoding that has 256 glyphs
\linespread{1.05} % Line spacing - Palatino needs more space between lines
\usepackage{microtype} % Slightly tweak font spacing for aesthetics

\usepackage[italian]{babel} % Language hyphenation and typographical rules

\usepackage[hmarginratio=1:1,top=32mm,columnsep=20pt]{geometry} % Document margins
\usepackage[hang, small,labelfont=bf,up,textfont=it,up]{caption} % Custom captions under/above floats in tables or figures
\usepackage{booktabs} % Horizontal rules in tables

\usepackage{lettrine} % The lettrine is the first enlarged letter at the beginning of the text

\usepackage{enumitem} % Customized lists
\setlist[itemize]{noitemsep} % Make itemize lists more compact

\usepackage{abstract} % Allows abstract customization
\renewcommand{\abstractnamefont}{\normalfont\bfseries} % Set the "Abstract" text to bold
\renewcommand{\abstracttextfont}{\normalfont\small\itshape} % Set the abstract itself to small italic text


\usepackage{titlesec} % Allows customization of titles
\renewcommand\thesection{\Roman{section}} % Roman numerals for the sections
\renewcommand\thesubsection{\roman{subsection}} % roman numerals for subsections
\titleformat{\section}[block]{\large\scshape\centering}{\thesection.}{1em}{} % Change the look of the section titles
\titleformat{\subsection}[block]{\large}{\thesubsection.}{1em}{} % Change the look of the section titles

\usepackage{fancyhdr} % Headers and footers
\pagestyle{fancy} % All pages have headers and footers
\fancyhead{} % Blank out the default header
\fancyfoot{} % Blank out the default footer
\fancyhead[C]{Metodi Computazionali della Fisica} % Custom header text
\fancyfoot[RO,LE]{\thepage} % Custom footer text

\usepackage{titling} % Customizing the title section

\usepackage{hyperref} % For hyperlinks in the PDF

\usepackage{amsmath}

\usepackage{subfig}
\usepackage{siunitx}
\usepackage{pgfplots}
\usepgfplotslibrary{units}

%Flowchart
\usepackage{makeshape}
\usepackage{flowchart}
\usetikzlibrary{arrows}

%----------------------------------------------------------------------------------------
%	TITLE SECTION
%----------------------------------------------------------------------------------------

\setlength{\droptitle}{-4\baselineskip} % Move the title up

\pretitle{\begin{center}\Huge\bfseries} % Article title formatting
\posttitle{\end{center}} % Article title closing formatting
\title{Studio di algoritmi stocastici per la costruzione di quadrati magici} % Article title
\author{%
\textsc{Gabriele Bozzola} \\[1ex] % Your name
\normalsize Università degli Studi di Milano \\ % Your institution
\normalsize \href{mailto:bozzola.gabriele@gmail.com}{bozzola.gabriele@gmail.com} % Your email address
%\and % Uncomment if 2 authors are required, duplicate these 4 lines if more
%\textsc{Jane Smith}\thanks{Corresponding author} \\[1ex] % Second author's name
%\normalsize University of Utah \\ % Second author's institution
%\normalsize \href{mailto:jane@smith.com}{jane@smith.com} % Second author's email address
}
\date{Luglio 2016} % Leave empty to omit a date
\renewcommand{\maketitlehookd}{%
\begin{abstract}
\noindent In questo lavoro vengono presentati due algoritmi stocastici per costruire quadrati magici normali, che sono matrici di numeri naturali distinti che godono della proprietà che la la somma degli elementi su ciascuna riga e colonna e sulle diagonali è sempre la stessa, detta costante magica. La prima implementazione è un algoritmo genetico realizzato utilizzando diverse funzioni di fitness e metodi di selezione, mentre la seconda consiste in un algoritmo evolutivo, basato sul lavoro di Xie e Kang \cite{XieKang:2003}. Nessuna delle implementazioni dell'algoritmo genetico realizzate in questo lavoro ha portato alla costruzione di quadrati magici, a causa dell'impossibilità di formulare in modo sufficientemente adeguato il problema. L'algoritmo evolutivo, al contrario, si è mostrato efficacie nella costruzione di quadrati magici. Si sono quindi confrontati i risultati ottenuti con quelli originali di Xie e Kang, trovando un disaccordo in merito a come scalano i tempi di esecuzione all'aumentare dell'ordine del quadrato. Tale discostamento è probabilmente dovuto ai limiti dell'implementazione in Mathematica e all'ignoranza su come i risultati originali sono stati effettivamente ottenuti. In ogni caso questo lavoro dimostra come sia possibile implementare un algoritmo stocastico per un complicato problema di ordinamento in cui non è possibile costruire una fitness adeguata. Infine, alcune possibili modalità per migliorare l'attuale implementazione sono discusse.

\end{abstract}
}

%----------------------------------------------------------------------------------------

\begin{document}

% Print the title
\maketitle

%----------------------------------------------------------------------------------------
%	ARTICLE CONTENTS
%----------------------------------------------------------------------------------------

\section{Introduzione}

\lettrine[nindent=0em,lines=3]{U}n quadrato magico di ordine $ N $ è una matrice quadrata  $ M $  di dimensioni $ N\times N $ contenente numeri naturali distinti disposti in modo tale che la somma dei valori su ciascuna riga, colonna e diagonale sia sempre la stessa, detta \emph{costante o numero magico}. Qualora i numeri che compaiono sono i primi $ N^2 $ allora il quadrato è detto \emph{normale}, e la somma che devono le linee devono soddisfare è nota a priori in quanto esiste una relazione algebrica che lega l'ordine di un quadrato magico normale con la costante magica: per una matrice di ordine $ N $ è:
\[	 \mathit{m} = \frac{1}{2} N (N^2 + 1)	\]
La dimostrazione di questa elementare proprietà è riportata in appendice. Si dimostra inoltre che, ad eccezione di $ N = 2 $, è sempre possibile costruire almeno un quadrato magico per ogni ordine. Un esempio di quadrato magico normale è riportato in figura \ref{fig:magic_3x3}.


\begin{figure}[htbp]
	\centering
	\begin{tikzpicture}[scale = 1]
	\node at (-1,0)  {};
	
	\draw (0,0) grid (3,3);
	
	\node at (1.5, 1.5) {\large 5};
	\node at (0.5, 0.5) {\large 2};
	\node at (1.5, 0.5) {\large 9};
	\node at (0.5, 2.5) {\large 6};
	\node at (0.5, 1.5) {\large 7};
	\node at (2.5, 2.5) {\large 8};
	\node at (1.5, 2.5) {\large 1};
	\node at (2.5, 0.5) {\large 4};
	\node at (2.5, 1.5) {\large 3};
	
	\draw[->, thick] (3.25, 2.5) -- (3.5, 2.5) node[right] {\large 15};
	\draw[->, thick] (3.25, 1.5) -- (3.5, 1.5) node[right] {\large 15};
	\draw[->, thick] (3.25, 0.5) -- (3.5, 0.5) node[right] {\large 15};
	\draw[->, thick] (0.5, -0.25) -- (0.5, -0.5) node[below] {\large 15};
	\draw[->, thick] (1.5, -0.25) -- (1.5, -0.5) node[below] {\large 15};
	\draw[->, thick] (2.5, -0.25) -- (2.5, -0.5) node[below] {\large 15};
	\draw[->, thick] (3.25, -0.25) --(3.5, -0.5);
	\node at (3.75, -0.75) {\large 15};    
	\draw[->, thick] (-0.25, -0.25) --(-0.5, -0.5);
	\node at (-0.75, -0.75) {\large 15};    
	\end{tikzpicture}		
	\caption{Esempio di quadrato magico $ 3\times3 $ in cui sono riportati i valori delle somme di tutte le righe, le colonne e le diagonali. A meno di riflessioni non ne esistono di differenti.}	
	\label{fig:magic_3x3}
\end{figure}
\noindent
I quadrati magici hanno una storia molto lunga, iniziata probabilmente in Cina nel settimo secolo prima di Cristo, quando ai quadrati magici erano attribuite proprietà mistiche e rituali. Dalla Cina passarono in India e successivamente in Europa, dove furono continuamente considerati come oggetti dotati di poteri magici, il che spiega il loro utilizzo in discipline come l'alchimia o l'astrologia. Il primo studio matematicamente ponderato dei quadrati magici fu condotto da Simon De la Loubère alla fine del Seicento, che fornì anche un metodo di costruzione per alcuni tipi di quadrati. Da quel momento numerosi matematici si dedicarono allo studio delle proprietà dei quadrati magici, tra cui Euler e Lagrance e Lucas, anche se rimangono aperti molti interrogativi \cite{Abe:1994}. Ad oggi sono in palio $ \SI{8000}{\$} $ e diverse bottiglie di champagne per chi risolve alcuni di questi enigmi \cite{Boyer}. 

I quadrati magici hanno inoltre alcune applicazioni tecnologiche, tra cui nella crittografia \cite{TombaShiniraj:2014}, nella steganografia \cite{SahaBha:2015} (la tecnica di occultare informazioni nelle immagini), ma anche in teoria dei grafi o dei giochi, e in molti altri campi tra cui la fisica \cite{Loly:2003}.

Costruire quadrati magici non è un compito semplice, in quanto il loro numero è molto piccolo rispetto a tutte le possibilità e le equazioni che definiscono la \emph{magicità} di un quadrato non sono abbastanza stringenti per utilizzare approcci di forza bruta. Anche se a oggi non esiste ancora una formula che permetta di calcolare il numero di quadrati magici di ordine $ N $, si possono effettuare stime sono utilizzando metodi Monte Carlo e approcci con tecniche di meccanica statistica. I risultati di queste ricerche sul numero di quadrati magici sono riportate in tabella \ref{tab:numero_quadrati_magici}, dal quale risulta evidente che la magicità è una proprietà molto rara.

\begin{table}[htbp]
	\centering
	\caption{Stime del numero di quadrati magici distinti $ N_{ms} $ al variare dell'ordine $ N $ dei quadrati magici normali. $ N_{ns} $ è il numero di possibili quadrati magici normali distinti costruibili all'ordine $ N $. In questo caso due quadrati sono ritenuti distinti se non è possibile trasformare l'uno nell'altro utilizzando riflessioni. I presenti valori sono dovuti a Trump \cite{Trump} e sono ottenuti con metodi di Monte Carlo Backtracking con errori intorno a $ \SI{1}{\percent} $. %I valori noti sono quelli della sequenza OEIS A006052.
		}
	\begin{tabular}{cccc}
		$ N $ &       $ N_{ms} $        &       $ N_{ns} $        &  $ \si{\percent} $   \\ \hline
		2   &            0            &    $ \sim  10^{1} $     &          0           \\
		3   &            1            &     $ \sim 10^{5} $     &   $ \sim 10^{-5} $   \\
		4   &           880           &    $ \sim 10^{12} $     &   $ \sim 10^{-7} $   \\
		5   &       275 305 224       &    $ \sim 10^{24} $     &  $ \sim 10^{-18} $   \\
		6   &    $ \sim 10^{19} $     &    $ \sim 10^{41} $     &  $ \sim 10^{-22} $   \\
		20   &    $ \sim 10^{744} $    &    $ \sim 10^{868} $    &  $ \sim 10^{-124} $  \\
		35   &   $ \sim 10^{2992} $    &   $ \sim 10^{3252} $    &  $ \sim 10^{-250} $  \\
		50   &   $ \sim 10^{7000} $    &   $ \sim 10^{7410} $    &  $ \sim 10^{-410} $\\ \hline
		%	10000 & $ \sim 10^{756373366} $ & $ \sim 10^{756570555} $ & $ \sim 10^{-197189} $ \\ 
	\end{tabular} 
	\label{tab:numero_quadrati_magici}
\end{table}



\subsection{Approcci deterministici}
Nonostante il numero di quadrati magici sia piccolo  sono disponibili alcuni metodi di costruzione da molti anni, i più semplici dei quali sono già stati elencati da Kraitchik \cite{Krai:1942} nel 1942.

Per quadrati dispari è disponibile il metodo Siamese\footnote{Simon de la Loubère è stato ambasciatore francese in Siam, luogo dove ha appreso il metodo che porta il suo nome.} (anche noto come metodo di de la Loumbre), il metodo "a losanghe" di Conway e il metodo Pheru.
Per i quadrati di ordine pari esiste il metodo Medjig, mentre per quelli singolarmente pari, cioè di ordine $ 4n + 2 \text{ con } n \in \mathbb{N}$ sono noti il metodo LUX di John Conway e il metodo Strachey.

Questi metodi sono di due tipologie: costruzioni passo a passo, oppure completamenti. Nel primo caso si inizia posizionando uno o più numeri, e con passaggi ricorsivi (detti movimenti) si utilizzano i valori già posizionati nel quadrato per posizionarne uno successivo. Nel secondo caso si paro da una soluzione di ordine $ N $ per giungere ad una di $ N + 1 $ utilizzando apposite trasformazione, come nel metodo Strachey.

\subsection{Approcci stocastici}
Gli algoritmi elencati nella sezione precedente sono stati implementati in programmi di computer e risultano sufficientemente efficienti per la costruzione di quadrati magici. Tuttavia, tutti questi programmi hanno una limitazione: generano sempre il medesimo quadrato fissato l'ordine. Per questo motivo tali algoritmi risultano poco generalizzabili e quindi inadatti per studiare quadrati che, oltre ad essere magici, godono di ulteriori proprietà (ad esempio i quadrati bimagici, oppure i quadrati magici vincolati). A causa di ciò è conveniente provare ad implementare algoritmi in cui ci siano fattori di casualità che permettono di costruire sempre nuovi quadrati magici. In letteratura si trovano già alcuni risultati sulla costruzione di quadrati magici con questo tipo di metodologie, e i più efficienti algoritmi stocastici attualmente realizzati sono basati su tecniche note come \emph{metodi iper-euristici} che permettono di realizzare un quadrato magico vincolato di dimensioni $ 2600\times 2600 $ in meno di un minuto \cite{AhmedEnder:2014}. Questi algoritmi sono generalmente molto complessi e articolati, mentre in questo lavoro sono state implementate due soluzioni meno sofisticate: alcuni algoritmi genetici e uno evolutivo. Questi sono stati realizzati in Mathematica 8, con la scopo principale di ottenere dei programmi che effettivamente sono in grado di costruire dei quadrati magici. Gli algoritmi che riescono a convergere sono quindi stati caratterizzati in termini delle leggi di scala in funzione della dimensione dell'input e sono stati confrontati con i risultati presenti in letteratura. Si è utilizzata la versione 8 di Mathematica principalmente perché permette di parallelizzare alcune funzioni in modo estremamente semplice, come ad esempio con il comando \texttt{ParallelTable[]} o il comando \texttt{ParallelMap[]}, che sono i corrispettivi parallelizzati di \texttt{Table[]} e \texttt{Map[]}, girando su quattro core questo ha permesso di ridurre di circa il $ \SI{75}{\percent} $ i tempi di esecuzione rispetto ad un implementazione puramente sequenziale. Questi ed altri dettagli saranno discussi successivamente.

\subsection{Terminologia}

In questo lavoro si utilizzerà il termine \emph{linea} indicando in modo generico una riga o una colonna, laddove i termini riga e colonna designano i medesimi concetti generalmente utilizzati in algebra matriciale. Una linea si dice \emph{magica} se la somma dei numeri che la compongono è il numero magico. 

Si compie inoltre un innocuo abuso di linguaggio utilizzando la parola quadrato intendendo quella che matematicamente è una matrice quadrata.

Altra terminologia e notazione verrà introdotta pian piano.

\section{Algoritmi genetici}
% TODO CORREGGERE
Gli algoritmi genetici sono metodi di ottimizzazione stocastici che implementano le modalità dell'evoluzione biologica. Questi algoritmi utilizzano una popolazione di possibili soluzioni del problema (chiamati \emph{individui}) cercando di trovare quella che meglio approssima la vera soluzione del problema con il principio darwiniano di sopravvivenza del migliore. Tutti gli algoritmi genetici si basano su un ciclo di selezione - riproduzione - mutazione.
\paragraph{Selezione} Inizialmente si selezionano i migliori individui della popolazione secondo un parametro che è chiamato \emph{fitness}, la quale è una funzione dei \emph{geni}, ovvero delle caratteristiche della soluzione, che è generalmente codificata come una stringa di numeri. Gli individui con fitness più alta hanno maggiore probabilità di essere selezionati per la riproduzione.

\paragraph{Riproduzione} Dopo la selezione si producono figli a partire da coppie degli individui selezionati precedentemente. I figli sono generati simulando quella che è la riproduzione sessuata in biologia cioè con lo scambio di geni dei genitori (questo processo è noto come \emph{crossover}). Questa fase permette di costruire individui che hanno le caratteristiche migliori di entrambi i genitori in modo da avvicinarsi alla soluzione.

\paragraph{Mutazione} Infine vengono applicate delle mutazioni sui figli che ne alterno casualmente qualche caratteristica. In questo modo ci si assicura di esplorare tutto lo spazio delle soluzioni è di non fossilizzarsi in un massimo locale della funzione di fitness.
\\
Una volta che si è completato il ciclo si verifica se si è trovata la soluzione del problema, altrimenti i figli della presente generazione diventa i genitori della successiva e il ciclo si ripete. Il workflow base di un algoritmo genetico è riportato in figura \ref*{fig:workflow_genetic}. 
\begin{figure}[htbp]
	\centering
	\begin{tikzpicture}
		\def\smbwd{0.66\columnwidth}
		\node (start) at (0,0) [draw, terminal,
		minimum width=\smbwd] {INIZIO};
		\node (generapop) at (0, -1) [draw, process,
		minimum width=\smbwd] {GENERA POPOLAZIONE};
		\node (selgen) at (0, -2) [draw, process,
		minimum width=\smbwd] {SELEZIONA GENITORI};		
		\node (crossover) at (0, -3) [draw, process,
		minimum width=\smbwd] {CROSSOVER};		
		\node (muta) at (0, -4) [draw, process,
		minimum width=\smbwd] {MUTA};		
		\node (trovato) at (0,-6) [draw, decision,
		] {TROVATO?};
		\node (end) at (0,-8) [draw, terminal,
		minimum width=\smbwd] {FINE};		
		
		\draw[->] (start) -- (generapop);
		\draw[->] (generapop) -- (selgen);
		\draw[->] (selgen) -- (crossover);
		\draw[->] (crossover) -- (muta);
		\draw[->] (muta) -- (trovato);
		\draw[->] (trovato) --node[left]{SI} (end);
		\draw[->] (trovato) --node[above]{NO} (-2.75, -6) 
		-- (-2.75, -1.5) -- (0, -1.5);
	\end{tikzpicture}
	\caption{Diagramma di flusso di un algoritmo genetico. L'algoritmo può non convergere e rimanere bloccato nel loop. }
	\label{fig:workflow_genetic}
\end{figure}

\noindent
Il problema della costruzione di quadrati magici ha alcune delle caratteristiche adatte per essere affrontato con un algoritmo genetico:
\begin{itemize}
	\item Lo spazio delle soluzioni è estremamente vasto, consistendo nelle permutazioni di $ N^2 $ elementi, sottoposte a $ 2 N - 1 $ vincoli (uno per ogni riga, per ogni colonna e per le due diagonali). Lo spazio delle soluzioni ha quindi $ (N^2 - 2N - 1)! $ elementi (a titolo di esempio per $ N = 9 $ il numero di soluzioni possibili è più grande del numero di atomi presenti nell'universo osservabile). 
	\item La complessità del problema è fortemente NP, quindi tecniche di \emph{brute force} non sono attuabili.
	\item I quadrati magici possono essere codificati in modo diretto in individui dell'algoritmo genetico.
	\item Il problema può essere formulato come un problema di ottimizzazione di una funzione di fitness.
\end{itemize}
Sono stati implementati diversi algoritmi genetici, i quali differiscono tra loro principalmente per la scelta della funzione di fitness e del metodo di selezione. 

\subsection{Funzioni di fitness}
Le funzioni di fitness che sono state implementate in questo lavoro sono: 
\begin{itemize}
	\item \texttt{totalSquared}: La fitness di un individuo è data dalla somma dei quadrati delle differenze di ogni linea dal numero magico.
	\item \texttt{totalAbs}: La fitness di un individuo è data dalla somma dei valori assoluti delle differenze di ogni linea dal numero magico.
	\item \texttt{correctLines}: La fitness di un individuo è data dall numero di linee magiche. 
\end{itemize}
Ciascuna di queste funzioni di fitness ha una precisa espressione matematica in termini delle entrate della matrice e gode della proprietà che tutti quadrati magici di un certo hanno una fitness fitness definita (zero nei primi due casi e $ 2N + 2 $ nel terzo). 

\subsection{Metodi di selezione e crossover}
Ad ogni individuo è attribuita un valore di fitness, bisogna quindi farli riprodurli. Sono stati implementati diverti meccanismi per selezionare i genitori in modo da premiare contemporaneamente la bontà, ma anche per permettere sufficiente variabilità. Questi sono:
\begin{itemize}
	\item \texttt{fitnessProportionate}: Ciascun individuo ha una probabilità di essere selezionato per fare crossover proporzionale alla sua fitness, o all'inverso della fitness per quelle funzioni per cui gli individui migliori sono quelli con fitness minore.  
	\item \texttt{similarSquare}: Ciascun individuo ha una probabilità di essere selezionato per fare crossover proporzionale ad un fattore che dipende dalla fitness è dalla sua distanza dall'individuo migliore. In questo contesto per distanza si intende il numero di permutazioni necessarie a trasformare un quadrato in un altro. In qualche modo questo metodo è una implementazione di un sigma scaling \cite{Mitchell:1998}.
	\item \texttt{fittests}: I migliori \texttt{nFittests} individui si riproducono con eguale probabilità, dopodiché la popolazione è ripristinata alla dimensione iniziale aggiungendo il giusto numero di individui casualmente generati. 
	\item \texttt{elitism}: Un certo numero di individui è selezionato per passare direttamente alla generazione successiva, i rimanenti si riproducono con uno dei metodi precedenti.
\end{itemize}
Una volta che si è prodotta la lista dei genitori si fanno accoppiare scambiandosi geni con il crossover con una certa probabilità di crossover $ P_C $. Sono stati implementati due tipi di crossover:
\begin{itemize}
	\item Ad un punto verticale od orizzontale: si seleziona una posizione all'intero del quadrato, i figli sono ottenuti incrociando le porzioni di quadrato che precedono e che succedono tale posizione tra i due genitori. 
	\item Ad due punti verticale od orizzontale: si selezionano due posizioni all'interno del quadrato: i figli sono ottenuti scambiando tra i due genitori i numeri compresi tra le due posizioni.
\end{itemize}
La distinzione tra verticale e orizzontale consiste nel criterio con cui alcuni numeri sono considerati antecedenti o posteriori alla posizione di scambio. In figura \ref{fig:crosso} è mostrata questa distinzione. Crossover verticale e orizzontale sono equivalenti a meno di una trasposizione. 

Qualora sia in uso la fitness \texttt{correctLines} si utilizza invece un altro crossover: si selezionano una riga o una colonna da entrambi i genitori: i figli sono uguali ai genitori a meno di queste due linee scambiate. 

\begin{figure}[!htbp]
	\centering
	\subfloat[Crossover orizziontale]{
		\begin{tikzpicture}[scale = 1]
		\draw (0,0) grid (3,3);
		\draw 
			(0,1)[ultra thick] to (2,1)
			(2,1)[ultra thick] to (2,2)
			(2,2)[ultra thick] to (3,2);
		
		\draw[fill = gray, opacity = 0.30] (0,2) rectangle (3,3);
		\draw[fill = gray, opacity = 0.30] (0,1) rectangle (2,2);
		
		\node at (1.5, 1.5) {X};
		\end{tikzpicture}
	}
	\subfloat[Crossover verticale]{
		\begin{tikzpicture}[scale = 1]
		\draw (0,0) grid (3,3);
		\draw 
		(1,0)[ultra thick] to (1,1)
		(1,1)[ultra thick] to (2,1)
		(2,1)[ultra thick] to (2,3);
		
		\draw[fill = gray, opacity = 0.30] (0,0) rectangle (1,3);
		\draw[fill = gray, opacity = 0.30] (1,1) rectangle (2,3);
		
		\node at (1.5, 1.5) {X};
		\end{tikzpicture}
	}
	\caption{Crossover ad un punto. Assumendo che sia estratto il punto X come punto di taglio per il crossover, in un caso si considera come elementi precedenti quelli che sono}
	\label{fig:crosso}
\end{figure}

\noindent
Siccome si vogliono costruire quadrati magici normali è necessario che tutti i numeri siano distinti, per questo motivo i crossover possono produrre degli individui non validi. Qualora questo succeda i quadrati vengono aggiustati eliminando i numeri doppi e sostituendoli con valori accettabili estratti casualmente.


\subsection{Implementazione in Mathematica}


Per lanciare il programma si utilizza il comando \texttt{run[]}. Per gestire le varie possibili configurazioni con cui si desidera lanciare l'algoritmo genetico il comando supporta delle opzioni.




\section{Algoritmo evolutivo}
Gli algoritmi genetici si sono rivelati inadatti a risolvere il problema della costruzione dei quadrati magici, come verrà approfondito successivamente. Per superarne i problemi si è mostrato conveniente:
\begin{enumerate}
	\item Eliminare la fase di crossover e aumentare il numero di mutazioni effettuate sul singolo individuo.
	\item Effettuare controlli sistematici quando l'algoritmo comincia ad essere in condizioni di stallo.
\end{enumerate}
Un algoritmo evolutivo è quindi un algoritmo genetico in cui non si effettuano crossover, ma si utilizzano esclusivamente mutazioni, rese tuttavia più sofisticate per sopperire alla mancanza dei crossover, i quali in generale permettono di giungere più velocemente alla soluzione. 

L'algoritmo evolutivo implementato in questo lavoro è basato sull'idea di Xie e Kang \cite{XieKang:2003} che tiene conto anche della seconda miglioria.

\subsection{Algoritmo di Xie-Kang}

L'algoritmo di Xie-Kange oltre ad implementare i miglioramenti esposti all'inizio di questa sezione aggiunge un ulteriore contributo fondamentale: \emph{la congettura della costruzione a due fasi}. 

Per enunciare questa congettura è necessario definire una nuova tipologia di quadrati: i quadrati semimagici. Una matrice composta da numeri naturali differenti $ N\times N $ è detta \emph{quadrato semimagico} se è un quadrato magico a meno delle diagonali, ovvero se la somma dei valori su tutte le righe e su tutte le colonne è uguale al numero magico. Un quadrato semimagico è normale se le sue entrate sono tutti i numeri da $ 1 $ a $ N^2 $. 

\paragraph{Congettura della costruzione a due fasi}
Un quadrato semimagico è sempre completabile ad un quadrato magico utilizzando un numero finito di permutazioni di righe e di colonne oppure di rettificazioni locali. 

Non è disponibile una dimostrazione per questa affermazione, che è per questo motivo definita una \emph{congettura}.

\subsubsection{Codifica degli individui}
A differenza degli algoritmi genetici, nell'algoritmo evolutivo l'individuo non è direttamente il quadrato, bensì è una coppia di due matrici $ \left(M, \Sigma \right) $. Il primo quadrato, $ M $, è quello che si cerca di rendere magico, mentre il secondo, $ \Sigma $, contiene delle informazioni utili per le mutazioni. Gli elementi $ \sigma_{ij} $ di $ \Sigma $ determinano il range di valori che l'elemento $ m_{ij} $ può assumere a causa di una mutazione. $ \Sigma $ è una matrice dinamica, che subisce essa stessa mutazioni come $ M $ e che evolve tenendo in considerazione quanto $ M $ si discosta dall'essere un quadrato magico in termini di fitness e di linee non magiche.

La funzione di fitness $ f $ adottata è differente se il quadrato è semimagico oppure se possiede ancora linee non magiche:
\begin{itemize}
	\item Per quadrati non semimagici:
	\[	f(M) = \sum_{i=1}^{N}\Bigl\lvert\sum_{j=1}^{N} a_{ij} - \mathit{m} \Bigr\rvert + \sum_{i=1}^{N}\Bigl\lvert\sum_{j=1}^{N} a_{ji} - \mathit{m} \Bigr\rvert 	\]
	\item Per quadrati semimagici:
	\[	f(M) = \Bigl\lvert\sum_{j=1}^{N} a_{jj} - \mathit{m} \Bigr\rvert + \Bigl\lvert\sum_{j=1}^{N} a_{j,N-j+1} - \mathit{m} \Bigr\rvert 	\]	
\end{itemize}
Si definiscono $ \text{col}(k) $ come la somma di tutti gli elementi sulla colonna $ k $ e $ \text{row}(h) $ come la somma di tutti gli elementi sulla riga $ h $. (Se una riga $ s $ è magica allora vale che $ \text{row}(s) = \mathit{m}$ e analogamente per le colonne). E similmente siano dg1 la somma dei termini sulla diagonale principale, e dg2 la somma dei termini sull'antidiagonale, cioè:
\[\text{dg1} = \sum_{k = 1}^Na_{kk}  \qquad \text{dg2} = \sum_{k = 1}^Na_{k,-k}  \]
Dove con $ -k $ si intende l'indice $ N-k+1 $, che è il $ k $-esimo elemento della matrice leggendo da destra a sinistra.
Con queste notazioni la funzione di fitness può essere riscritta come:
\[ f(M) = 
\begin{cases}
\sum_{i = 1}^{N}\left(\text{row}(i) + \text{col}(i) \right) & \text{semimagico} \\
- \left(\text{dg1} + \text{dg2} \right) & \text{altrimenti} 
\end{cases}
\]
Si è scelto di utilizzare una fitness negativa per i quadrati semimagici in modo che ogni quadrato semimagico sia evolutivamente preferito a tutti i quadrati che hanno ancora linee non magiche. Questo accorgimento permette di trovare sempre l'individuo migliore di una popolazione anche se questa è composta da quadrati semimagici e non cercando l'individuo che ha fitness negativa più vicina a zero.   
%In questo modo l'individuo migliore è quello che ha fitness negativa più vicina al valore $ 0 $.

\subsection{Mutazioni}
Siccome negli algoritmi evolutivi non vi è crossover, per esplorare lo spazio delle soluzioni si utilizzano esclusivamente mutazioni e non è necessario lavorare con una popolazione composta da numero elevato di individui, ma se ne utilizza uno solo, il quale produce un numero fissato di figli che subiscono diverse mutazioni.

Sono state utilizzati due tipi di mutazioni: le mutazioni puntuali che coinvolgono solo due numeri, e le mutazioni lineari, le quali invece coinvolgono tutti i valori di una linea.

Sia randint$ (a,b) $ una funzione che estrae un numero intero nell'intervallo $ (a,b) $ con probabilità uniforme. Questa funzione è fornita da Mathematica come \texttt{Random[Integer]} e \texttt{RandomInteger[]}. Siano inoltre $ n_{row} $ e $ n_{col} $ rispettivamente il numero di righe e di colonne non magiche del quadrato.

\subsubsection{Mutazioni puntuali}
Si definiscono degli insiemi di mutazione:
\begin{itemize}
	\item $ S_1 $:  Numeri la cui riga e colonna non è magica.
	\item $ S_{2r} $: Numeri in righe non è magiche.
	\item $ S_{2c} $: Numeri in colonne non è magiche.
	\item $ S_{2} = S_{2r} \cup S_{2c} $
\end{itemize}
E' evidente inoltre che:
\[S_1 = S_{2r} \cap S_{2c} \]
A meno che uno di questi insiemi non sia vuoto, ogni individuo è mutato con una delle seguenti tipologie di mutazione selezionata in modo casuale:

\paragraph{Mutazione da $ \mathbf{S_1} $ a $ \mathbf{S_2} $}
Ogni elemento di $ S_1 $ è sottoposto a mutazione con probabilità $ 1\slash(n_{row}n_{col}) $. Se un elemento $ x $ aventi indici $ i $ e $ j $ è selezionato per essere mutato, allora si calcola il valore:
\[ n = 	x + \text{randint}(-\sigma_{ij}, \sigma_{ij})  \]
Il quale viene aggiustato se produce risultati non accettabili:
\[
\begin{cases}
n = \text{randint}(1,N) & \text{se} \quad n < 1  \\
n = N^2 - \text{randint}(0,N) & \text{se} \quad n > N^2  
\end{cases}
\]
Si cerca quindi in $ S_2 $ l'elemento che più si avvicina a $ n $, cioè il numero $ t $ in $ S_2 $ tale che sia minimizzato il valore di 
\[\min_{t \in S_2} \lvert n - t \rvert \]
Gli elementi $ n $ e $ t $ sono quindi scambiati. Una volta avvenuto lo scambio si effettua una mutazione anche sul valore di $ \sigma_{ij} $.
Il nuovo valore $ z $ di $ \sigma_{ij} $ è dato da: 
\[ z = 	\sigma_{ij} + \text{randint}(-1, 1)  \]
Anche in questo caso per evitare di avere dei valori insensati si pone:
\[
z = \text{randint}(1,\sigma_t) \quad \text{se} \quad z < 1 \quad \text{o} \quad  z > \sigma_t 
\]
Dove $ \sigma_t $ definisce in qualche modo un "parametro di salute" del quadrato: 
$ \sigma_t $ è definito così:
\[ \sigma_t = 
\begin{cases}
\lvert f(M) \rvert \slash \left(n_{row} + n_{col}\right) & \text{se} \quad n_{row}n_{col} \not = 0  \\
\lvert f(M) \rvert \slash n_{diag} & \text{se} \quad n_{row}n_{col} = 0 
\end{cases}
\]

Quando $ \sigma_t $ è piccolo significa che il quadrato è vicino ad essere magico, e quindi bisogna fare piccole mutazioni, mentre al contrario se $ \sigma_t $ è grande allora significa la fitness è alta e sono necessarie grandi mutazioni per rendere il quadrato magico.

\paragraph{Mutazione da $ \mathbf{S_2} $ a $ \mathbf{S_2} $}
Ogni elemento $ x $ di $ S_2 $ è sottoposto a mutazione con probabilità che dipende determinata dall'appartenenza agli insiemi $ S_{2r} $ e $ S_{2c} $:
\[ P_M(x) = 
\begin{cases}
1\slash n_{row} & \text{se} \quad x \in S_{2r} \\
1\slash n_{col} & \text{se} \quad x \in S_{2c} \\
1\slash \left(n_{row} n_{col} \right) & \text{se} \quad x \in S_{2r} \cap S_{2c} \\
\end{cases}
\]
Se $ x $ è sottoposto a mutazione si esegue esattamente quello che si è fatto per la mutazione esposta precedentemente. 
\paragraph{Mutazione da $ \mathbf{S_2} $ a $ \mathbf{M} $}
Questa mutazione è uguale alla precedente, a meno del fatto che gli elementi con cui si scambiano quelli di $ S_2 $ sono in tutta la matrice $ M $.

\subsubsection{Mutazioni lineari}
Una volta che l'algoritmo trova almeno un quadrato avente tutte le righe e le colonne magiche, cioè un quadrato semimagico, per evitare di perdere questi risultati vengono utilizzate mutazioni lineari al posto di quelle puntuali. Queste consistono nello scambio di due righe o di due colonne scelta casualmente, in questo modo sicuramente l'individuo continua ad avere tutte le righe e tutte le colonne magiche. 

Per ogni individuo si eseguono $ N $ mutazioni lineari con probabilità unitaria. Si nota tuttavia che è possibile che le due linee che vengono estratte per essere scambiate coincidano, e ciò corrisponde a non aver effettuato alcuna mutazione. Equivalentemente si può quindi dire che la probabilità di mutazione lineare è di $ 1 - \frac{1}{N} $ considerando tuttavia solo linee differenti. 

\subsection{Metodi di selezione}
Una volta che tutta la popolazione è andata incontro a mutazione bisogna selezionare quale sarà il nuovo genitore. Vengono utilizzati due metodi di selezione (\emph{evolution strategies}) differenti per incentivare o meno la variabilità degli individui. Questi sono metodi standard negli algoritmi evolutivi:
\begin{itemize}
	\item$ (\mu, \lambda)-ES $: La nuova generazione di genitori è formata dai migliori figli della precedente.
	\item $ (\mu + \lambda)-ES $: La nuova generazione è formata dagli individui migliori tra i genitori e i figli della generazione precedente.
\end{itemize}
In queste diciture $ \mu $ indica i genitori della generazione precedente, mentre $ \lambda $ i figli. 
L'utilizzo della seconda strategia evolutiva garantisce che non vengono persi individui buoni ma modificati dalle mutazioni, mentre l'utilizzo del primo permette di esplorare più velocemente lo spazio delle soluzioni. 

Nell'algoritmo implementato in questo lavoro sono state utilizzate entrambe le strategie evolutive a seconda di quale sia più utile nel momento della selezione. 

\subsection{Rettificazioni locali}

Senza intervenire direttamente in modo sistematico sulla costruzione dei quadrati, anche l'algoritmo evolutivo, come quello genetico, non è molto più efficiente di una ricerca casuale nello spazio delle soluzioni, e per questo motivo non converge quando lo spazio delle soluzioni è troppo grosso, e fallisse già con quadrati di piccole dimensioni. Per ovviare a questo problema Xie e Kang hanno proposto di utilizzare delle \emph{rettificazioni locali}: quando gli individui sono abbastanza buoni vengono passati in rassegna per cercare se vi sono degli scambi che diminuiscono il numero di righe sbagliate oppure che rendono le diagonali magiche. Si definiscono \emph{rettificazioni locali lineari} quelle che hanno come obiettivo la diminuzione delle righe non magiche, mentre \emph{rettificazioni locali diagonali} quelle che intendono aggiustare le diagonali.

\subsubsection{Rettificazioni locali lineari}
Sono state implementate due tipologie di rettificazioni locali lineari: lo scambio di una coppia, e lo scambio di due coppie tali che soddisfino alcune condizioni. Queste condizioni garantiscono che lo scambio renda magica una o più linee senza rovinare le altre. Non si fanno analisi a più di due coppie perché sarebbe un compito computazionalmente troppo oneroso. Ricordando che col$ (k) $ è la somma degli elementi sulla $ k- $esima colonna e row$ (h) $ è la somma degli elementi sulla $ h- $esima riga:

\paragraph{Scambio di una coppia} Due numeri $ a_{ks} $ e $ a_{ls} $ sono scambiati alla riga $ k $ e $ l $ e alla colonna $ s $ se sono soddisfatte: 
\begin{itemize}
	\item $ \text{row}(k) - \mathit{m} = a_{ks} - a_{ls} $
	\item $ \mathit{m} - \text{row}(l) = a_{ks} - a_{ls} $
\end{itemize}
Un esempio di questa rettificazione è riportato in appendice. 

\paragraph{Scambio di due coppie} I numeri $ a_{ks} $ e $ a_{lt} $ sono scambiati con i numeri $ a_{ls} $ e $ a_{kt} $ (il primo con il primo e il secondo con il secondo), corrispondenti alle righe $ k $ e $ l $ e alle colonne $ s $ e $ t $ se sono soddisfatte:
\begin{itemize}
	\item $ \text{row}(k) - \mathit{m} = a_{ks} + a_{kt} -a_{lt} - a_{ls} $
	\item $ \mathit{m} - \text{row}(l) = a_{ks} + a_{kt} -a_{lt} - a_{ls} $
\end{itemize}

Le condizioni duali sono applicate anche alle colonne con le ovvie sostituzioni.  

\subsubsection{Rettificazioni locali diagonali}
Una volta che si è realizzato un quadrato semimagico per ottenere il quadrato magico bisogna intervenire utilizzando metodi deterministici. 
I metodi implementati sono scambi di coppie di elementi, oppure di intere linee. Ricordando che dg1 e dg2 sono la somma degli elementi sulla diagonale e sull'antidiagonale rispettivamente. 

\paragraph{Scambio puntuale} 
Se sono soddisfatte le condizioni:
\begin{itemize}
	\item $ a_{ii} + a_{ij} = a_{ji} + a_{jj} $
	\item $ \left(a_{ii} +  a_{jj} \right) - \left(a_{ij} +  a_{ji} \right) = \text{dg1} - \mathit{m}$
\end{itemize}
allora $ a_{ii} $ è scambiato con $ a_{ji} $ e $ a_{ji} $ con $ a_{jj} $. In modo simmetrico per l'antidiagonale.

\paragraph{Scambio lineare}
Se sono soddisfatte le condizioni:
\begin{itemize}
	\item $ \left(a_{ii} +  a_{jj} \right) - \left(a_{ij} +  a_{ji} \right) = \text{dg1} - \mathit{m}$
	\item $ \left(a_{i,-i} + a_{j,-j}\right) - \left(a_{i,-j} + a_{j,-i}\right) = \text{dg2} - \mathit{m}$
\end{itemize}
allora la riga $ i $ è scambiata con la riga $ j $. Simmetricamente con colonne.

\subsection{Implementazione in Mathematica}

Il punto critico dell'implementazione sono le rettificazioni locali: è possibile implementarle senza manipolare direttamente gli indici e quindi sfruttando gli strumenti nativi di Mathematica?

Quando si esegue questa correzione tutto il quadrato viene passato in rassegna, per far ciò si utilizzano cicli innestati: uno che fissa il primo elemento, e il secondo che fa scorrere l'intero quadrato in cerca di numeri che soddisfino le condizioni richieste. Per questo motivo in generale il numero di cicli innestati è quattro, due per gli indici del primo elemento, e due per gli indici del secondo elemento, per questo motivo la complessità della rettificazione è sicuramente maggiore a $\mathcal{O}(N^4)$. 

L'itero algoritmo è esposto nel diagramma di flusso riportato in figura \ref{fig:flowchart}


\section{Risultati}

\subsection{Algoritmi genetici}
Gli algoritmi genetici implementati non sono stati in grado di produrre i risultati sperati: nessuna combinazione di fitness, e criterio di selezione è risuscita a produrre quadrati di dimensioni superiori al $ 3\times 3 $. I risultati ottenuti sono riportati in tabella \ref{tab:risultati_genetic}.

\begin{table}[htbp]
	\centering
	\caption{Risultati ottenuti: $ N $ è l'ordine del quadrato, $ F,C $ la funzione di fitness e il criterio di selezione, $ n_{tent} $ il numero di esecuzioni dell'algoritmo, $ n_{ok} $ il numero di quadrati costruiti con successo entro $ \num{10000} $ generazioni. Le abbreviazioni utilizzate sono riportate in tabella \ref{tab:abb} }
	\begin{tabular}{cc|cc}
		\hline
		$ N $ &    F,C    & $ n_{tent} $ & $ n_{ok} $ \\ \hline
		3   & tS, fP, E &      10      &     7      \\
		3   &  tS, fP   &      10      &     4      \\
		3   & tA, fP, E &      10      &     8      \\
		3   & cL, F, E  &      10      &     6      \\
		3   & tS, sS, E &      10      &     1      \\
		4   & tS, fP, E &      10      &     0      \\
		4   & tS, F, E  &      10      &     0      \\
		4   &  tA, fP   &      10      &     0      \\
		4   &  tA, sS   &      10      &     0      \\
		4   &  cL, fP   &      10      &     0      \\
		10   & cL, fP, E &      10      &     0      \\
		10   & tS, fP, E &      10      &     0      \\
		10   & tS, F, E  &      10      &     0      \\ \hline
	\end{tabular} 
	\label{tab:risultati_genetic}
\end{table}

\begin{table}[htbp]
	\centering
	\caption{Abbreviazioni utilizzate nella tablela \ref{tab:risultati_genetic}. }
	\begin{tabular}{c|c}
		Sigla &            Metodo             \\ \hline
		fP   & \texttt{fitnessProportionate} \\
		sS   &    \texttt{similarSquare}     \\
		F   &       \texttt{fittests}       \\
		E   &       \texttt{elitism}        \\
		tS   &     \texttt{totalSquared}     \\
		tA   &       \texttt{totalAbs}       \\
		cL   &     \texttt{correctLines}     \\ \hline
	\end{tabular} 
	\label{tab:abb}
\end{table}

\subsection{Algoritmo di Xie-Kang}
Al contrario degli algoritmi genetici, l'algoritmo evolutivo ha prodotto con successo un discreto numero di quadrati magici. Sono stati costruiti quadrati di ordine dal $ 10 $ a $ 40 $, e in nessun caso l'algoritmo si è trovato in una condizione metastabile e non è giunto a convergenza. Curiosamente, invece, per quadrati di dimensioni piccole (da $ 4\times 4 $ a $ 6\times6 $) è capitato che il programma rimanga in una condizione metastabile. 

Si sono raccolte delle statistiche per caratterizzare come varia il tempo di esecuzione del programma al variare della dimensione dell'input e per confrontare i dati raccolti con quelli di Xie e Kang. 

Nella tabella \ref{tab:risultati_xie_kang} sono riportati i dati raccolti, mentre nella figura \ref{fig:scala_xie_kang} sono rappresentati i tempi di esecuzione al variare dell'ordine del quadrato con un possibile andamento interpolante. I dati raccolti si accordato con una legge di potenza avente per esponente un valore compreso tra $ 5 $ e $ 6 $. Con i dati a disposizione questo esponente vale $ \sim \num{5.26} $ con un coefficiente di determinazione $ R^2 = \num{0.96} $. Questo è un miglioramento sostanziale rispetto alla ricerca \emph{brute-force}.

I fit sono realizzati con il metodo dei minimi quadrati.

\begin{table}[htbp]
	\centering
	\caption{Risultati ottenuti: $ N $ è l'ordine del quadrato, $ n_{tent} $ il numero di esecuzioni dell'algoritmo, $ n_{ok} $ il numero di quadrati costruiti con successo entro $ \num{30000} $ generazioni, $ \tau $ il tempo medio di costruzione, $ \tau \slash \tau_0 $ è il rapporto tra il tempo medio con il tempo medio per la costruzione del quadrato con $ N = 10 $, $ n_{gen} $ è il numero medio di generazioni.}
\begin{tabular}{c|ccccc}
	\hline
	$ N $ & $ n_{tent} $ & $ n_{ok} $ &        $ \tau $        & $ \tau \slash \tau_0 $ & $ n_{gen} $ \\ \hline
	  3   &      10      &     10     & $ \SI{0.12}{\second} $ &           0            &      3      \\
	 10   &      10      &     10     &  $ \SI{55}{\second} $  &           1            &     178     \\
	 15   &      10      &     10     & $ \SI{5.75}{\minute} $ &           6            &     536     \\
	 20   &      10      &     10     & $ \SI{31.2}{\minute} $ &           33           &    1085     \\
	 25   &      10      &     10     &  $ \SI{1.73}{\hour} $  &          112           &    1893     \\
	 30   &      10      &     10     &  $ \SI{4.23}{\hour} $  &          275           &    3007     \\
	 35   &      10      &     10     & $ \SI{12.38}{\hour} $  &          824           &    4359     \\
	 40   &      10      &     10     &                        &           1            &  \\ \hline 
\end{tabular} 
\label{tab:risultati_xie_kang}
\end{table}

\begin{table}[htbp]
	\centering
	\caption{Risultati ottenuti: $ N $ è l'ordine del quadrato, $ n_{tent} $ il numero di esecuzioni dell'algoritmo, $ n_{ok} $ il numero di quadrati costruiti con successo entro $ \num{30000} $ generazioni, $ \tau $ il tempo medio di costruzione, $ \tau \slash \tau_0 $ è il rapporto tra il tempo medio con il tempo medio per la costruzione del quadrato con $ N = 10 $, $ n_{gen} $ è il numero medio di generazioni.}
	\begin{tabular}{c|ccccc}
		\hline
		$ N $ & $ n_{tent} $ & $ n_{ok} $ &        $ \tau $        & $ \tau \slash \tau_0 $ & $ n_{gen} $ \\ \hline
		  3   &      10      &     10     & $ \SI{0.22}{\second} $ &           0            &      4      \\
		 10   &      10      &     10     &  $ \SI{69}{\second} $  &           1            &     377     \\
		 15   &      10      &     10     & $ \SI{4.37}{\minute} $ &           3            &    1109     \\
		 20   &      10      &     10     & $ \SI{26.3}{\minute} $ &           22           &    2852     \\
		 25   &      10      &     10     &  $ \SI{1.51}{\hour} $  &          78            &    4855     \\
		 30   &      10      &     10     &  $ \SI{4.23}{\hour} $  &          275           &    3007     \\
		 35   &      10      &     10     & $ \SI{12.38}{\hour} $  &          824           &    4359     \\
		 40   &      10      &     10     &                        &           1            &  \\ \hline
	\end{tabular} 
	\label{tab:risultati_xie_kang_10}
\end{table}

\begin{figure}[htbp]
	\centering
	\begin{tikzpicture}
	\begin{axis}[
	axis lines=left, enlarge x limits=true,
	%	xtick={10,15,20,25,30},
	xtick = data,
	scaled y ticks=base 10:-3,
	ymin=0,
	xmin=7.5,
	title = Tempo di esecuzione vs ordine,  
	xlabel = Ordine,
	ylabel = Tempo di esecuzione,
	grid=major,
	grid style={dashed,gray!30},	
	y unit=\si{\second},
	width=\columnwidth,
	]
	\addplot [only marks, error bars/.cd,
	y dir=both, y explicit]
	table[x=x, y=y, y error=error]{
		x  y	    error
		10 55.2336 10.385984
		15 345.519 131.58943
		20 1873.96 629.16364
		25 6229.42 1673.8868
		30 15222.0 3930.1511
		35 45535.3 13768.331
		40 77382.6 5193.94
	};
	\addplot [only marks, mark=o, error bars/.cd,
	y dir=both, y explicit]
	table[x=x, y=y, y error=error]{
		x  y	    error
		10 69.3912 16.0766
		15 262.52  38.9824
		20 1578.77 542.591
		25 5424.71 1484.1
	};
	\addplot [blue, thick, smooth] table{
		10 55.2336
		20 1100
		30 4442
		40 16060
	};
	\addplot[red,domain=1:40,samples=100, thick] {0.0002157263137*x^(5.342445008)};
	\addplot[green,domain=1:40,samples=100, thick]
	{0.0008565498702*x^(4.81268856)};
	\node at (axis cs:32, 2000) [anchor=west, rotate = 36] {\small Xie Kang};
	\node at (axis cs:28.5, 20000) [anchor=west, rotate = 62] {\small pop = 25};
	\end{axis}
	\end{tikzpicture}
	\caption{Tempi di computazione medi su dieci esecuzioni dell'algoritmo evolutivo per quadrati di ordine dal 10 al 30. La curva rossa descrive una possibile legge di scala: è una legge di potenza $ \alpha x^{\beta} $ con esponente $ \beta $ compreso tra $ 5 $ e $ 6 $. Le barre di errore sono le deviazioni standard delle distribuzioni dei dieci risultati effettuati per ogni ordine. In blu sono i dati di Xie e Kang, rinormalizzati sul tempo di computazione. I fit sono realizzati con il metodo dei minimi quadrati.}
	\label{fig:scala_xie_kang}
\end{figure}

Confrontando i dati ottenuti con quelli di Xie e Kang si nota che l'algoritmo implementato in questo lavoro si comporta decisamente peggio in termini di legge di scala rispetto all'originale. Si nota tuttavia che il numero di generazioni necessarie per raggiungere il quadrato magico è sempre notevolmente minore (circa inferiore del $ \SI{50}{\percent} $) rispetto a quelle richieste di Xie e Kang: questo è dovuto al fatto che in questa implementazione ogni generazione è composta da una popolazione di 25 individui, mentre nell'originale di Xie e Kang sono solo 10. Si è adoperata questa scelta perché si è verificato che per i quadrati $ 10\times 10 $ la convergenza avviene circa il $ \SI{20}{\percent} $ più velocemente. E' tuttavia possibile che per ordini superiori questa scelta sia dannosa e abbia causato questo bias nei tempi.

La dipendenza della dimensione della popolazione inoltre incide anche per un ulteriore motivo: le mutazioni e le rettificazioni sono eseguite in parallelo su tutti i core a disposizione. Nella macchina usata venivano in effetti istanziati quattro thread, e per questo motivo le popolazioni che non sono potenze di 4 non sono ottimali.

Inoltre si nota che Xie e Kang hanno trovato che la legge di scala è quasi perfettamente come $ N^4 $ (con i dati a disposizione il corretto esponente di una power law interpolante è $ \num{4.04} $), il quale è il limite inferiore ottenuto da considerazioni teoriche nella implementazione realizzata in questo lavoro.

\section{Conclusioni}

\subsection{Limiti degli algoritmi stocastici}
In questo lavoro sono stati analizzati due possibili algoritmi stocastici per la costruzioni di quadrati magici, di cui, tuttavia, solo uno è in grado di arrivare effettivamente ad un risultato. 

Il crossover risulta inutile in quanto la prescrizione che il quadrato abbia tutti numeri diversi impedisce al crossover di produrre un individuo migliore a partire da due quadrati buoni selezionando opportunamente le righe. A causa delle ricostruzioni del quadrato dopo il crossover, gli algoritmi genetici con crossover per questo scopo sono quasi equivalenti alla ricerca casuale. 

Il motivo per cui gli algoritmi genetici non convergono è che non si può trovare una funzione di fitness che individui un un percorso verso l'individuo perfetto. E' possibile costruire un quadrato che è perfetto a meno di due sole permutazioni ma che ha fino a otto linee non magiche, e viceversa è possibile costruire un quadrato che è ha tutte le linee magiche a meno di due, eppure che sia molto distante in termini di permutazioni da un quadrato magico.


\subsection{Confronto con i risultati di Xie e Kang}

L'attuale implementazione è quindi adatta per la costruzioni di quadrati di ordine relativamente piccolo.

Anche questa implementazione individua tre fasi nella ricerca del quadrato magico:
\begin{enumerate}
	\item Durante la prima fase la fitness decresce vertiginosamente mentre il numero di linee non magiche rimase costante: nessuna linea ha la somma corretta.
	\item Quando la fitness è sufficientemente bassa (inferiore a $ 50 \times N $) cominciano ad essere utilizzati i meccanismi di rettificazione locale lineare: questo aggiusta molte linee, ma non abbassa sensibilmente la funzione di fitness.
	\item Infine si riesce a produrre un quadrato semimagico, in questa fase si utilizzano le permutazioni lineari e le rettificazioni per esplorare tutto lo spazio delle soluzioni, come mostra il grafico \ref{fig:fitvsgen}, in cui le brusche oscillazioni di fitness indicano che molte soluzioni differenti sono state tentata. 
\end{enumerate}


L'indagine sui tempi di esecuzione delle varie subroutine dell'algoritmo mostra come la quasi totalità del tempo sia spesa nel cercare di rettificare le linee del quadrato, in particolare nella rettificazione a due coppie. Ci si attendeva questo comportamento in quanto l'implementazione ha richiesto l'utilizzo di quattro cicli innestati per controllare tutte le coppie di elementi del quadrato. Questo significa che per un quadro $ N\times N $ in questa fase vengono eseguiti circa $ N^4 $, che 

Le rettificazioni ad una coppia invece effettuano $ 2(N-1)N^2 \sim N^3 $ controlli ogni volta, e quindi per quadrati grandi influiscono sensibilmente meno sul tempo di elaborazione. Per questo non si sono implementate rettificazioni che coinvolgono un numero maggiore di due di coppie.

\begin{table}[htbp]
	\centering
	\caption{Tempi di esecuzioni medi delle varie routine dell'algoritmo per quadrato di ordine 20. Siccome \texttt{rectifyLines}  ha complessità maggiore degli altri metodi, quindi aumentando l'ordine tende a occupare tutto il tempo di elaborazione. Il restante tempo è speso nell'eseguire operazioni per produrre le statistiche. L'ultima riga specifica come si suddivide il tempo di esecuzione della routine \texttt{rectifyLines} nelle due subroutine per la rettificazione a una coppia o a due coppie. Questi dati sono nel caso della popolazione di 25 elementi.}
\begin{tabular}{cc}
	\hline
	         Routine          & Tempo speso ($ \si{\percent} $) \\ \hline
	 \texttt{selectFittest}   &          $ \sim 0.01 $          \\
	     \texttt{mutate}      &          $ \sim 0.7 $           \\
	\texttt{rectifyDiagonals} &          $ \sim 7.7 $           \\
	  \texttt{rectifyLines}   &           $ \sim 91 $           \\
	 \begin{tabular}{c|c}
	\texttt{onePair}  &   \texttt{twoPairs}
	\end{tabular} 	   		  & \begin{tabular}{c|c}
	$ \sim 13 $   &   $ \sim 87 $ 
\end{tabular} 		\\
	  \hline
\end{tabular} 
	\label{tab:tempi_gentic}
\end{table}

\subsection{Possibili sviluppi futuri}
L'attuale implementazione dell'algoritmo evolutivo riesce sempre a produrre quadrati magici, tuttavia il tempo di elaborazione necessario per costruire quadrati di grandi dimensioni è molto elevato, come si nota dalla tabella \ref{tab:risultati_xie_kang}, e per questo motivo è impensabile utilizzarlo per costruire quadrati ancora più grandi. La quasi totalità del tempo di elaborazione è spesa nel cercare di rettificare i quadrati, questo perché tali processi devono passare in rassegna l'intero quadrato più volte alla ricerca di determinate condizioni, e per questo motivo l'implementazione contiene numerosi cicli nested, che la rendono molto pesante dal punto di vista del tempo di esecuzione.

Così come è implementata questa funzione non può essere parallelizzata perché si cerca di eseguire tutti i possibili scambi che migliorano il quadrato, e una volta effettuato uno scambio il quadrato su cui si lavora cambia. Tuttavia è possibile implementare la funzione di rettificazione in modo che quando è eseguito uno scambio termini l'esecuzione, in questo modo sono necessarie più generazione, ma diventa possibile implementare la funzione in modo altamente parallelo: ad ogni thread è dato un sottoinsieme di tutte i controlli che bisogna effettuare, quando uno di questi risulta positivo la routine termina e si effettua lo scambio. In questo modo si evita che se in un thread la condizione è verificata e si effettua uno scambio gli altri thread lavorino con il quadrato nello stato precedente. Questa parallelizzazione porterebbe notevoli vantaggi in termini di tempo di computazione della singola generazione.

Il tempo di computazione può essere sensibilmente ridotto riscrivendo i metodi di rettificazione in modo da renderli compilabili con il comando \texttt{Compile[]}.

Mathematica si è rivelato non essenziale ai fini dell'implementazione dell'algoritmo, e anzi probabilmente ne ha limitato le potenzialità. Alcune funzioni native, come \texttt{Map[]}, \texttt{Table[]}, \texttt{Replace[]} sono state utilizzate pesante e si sono rivelate strumenti di grande aiuto per la semplificazione del codice. La gestione delle liste di Mathematica ha permesso di scrivere in maniera concisa ed elegante tutti i metodi che si applicano alla intere popolazioni intere.

Tuttavia, il cuore dell'algoritmo, cioè i metodi di rettificazione, richiedono che si percorra l'intero quadrato più volte lavorando esplicitamente con gli indici, e questo costituisce un grosso limite per \texttt{Mathematica}, il quale non gestisce in modo sufficientemente le risorse per questi cicli in maniera altrettanto efficiente rispetto a linguaggi compilati come il \texttt{C}.

Il fatto che sia possibile in linea teorica compilare l'intero algoritmo di Xie e Kang con Mathematica mostra come effettivamente non sia necessario tale linguaggio ai fini dell'implementazione. 

Si è mostrato come l'approccio stocastico + deterministico sia re

Eseguire dieci costruzioni di quadrati dal $ 3\times 3 $ al $ 40\times40 $ richiede circa due settimane di computazione, per questo motivo non si è ulteriormente indagata come la dimensione della popolazione, che è sostanzialmente l'unico parametro che è possibile impostare direttamente, incida sul tempo di esecuzione. Si è tuttavia mostrato che questo parametro ha un impatto non trascurabile: si potrebbe rendere ulteriormente l'algoritmo più veloce trovando il parametro ottimale.


\section{Appendice}

\subsection{Calcolo del numero magico per un quadrato magico normale}
Dato un quadrato magico normale (cioè che contiene tutti i numeri da $ 1 $ a $ N $) allora ciascuna linea e le diagonali hanno per somma il valore magico $ \mathit{m} $, questo significa che sommando tutti i numeri del quadrato si ottiene $  N \mathit{m} $ che è la somma di tutte le somme di ogni riga. Quindi:
\[  N \mathit{m} = \sum_{n = 1}^{N^2}n		\]
Ma la somma al membro destro può essere valutata esplicitamente:
\[	\sum_{n = 1}^{N^2}n = \frac{1}{2} N^2 (N^2 + 1)	\]
Da cui utilizzando la relazione precedente:
\[	 \mathit{m} = \frac{1}{2} N (N^2 + 1)	\]

\subsection{Esempio di rettificazione lineare}
Si riporta qui un esempio di rettificazione locale lineare: con una permutazione si passa da un quadrato con una sola riga magica, ad uno con tutte le righe magiche.
\begin{figure}[htbp]
	\centering
	\subfloat[Prima]{
		\begin{tikzpicture}[scale = 1]
		\draw (0,0) grid (3,3);
		\node at (1.5, 1.5) {\large 3};
		\node at (0.5, 0.5) {\large 2};
		\node at (1.5, 0.5) {\large 7};
		\node at (0.5, 2.5) {\large 1};
		\node at (0.5, 1.5) {\large 4};
		\node at (2.5, 2.5) {\large 6};
		\node at (1.5, 2.5) {\large 5};
		\node at (2.5, 0.5) {\large 9};
		\node at (2.5, 1.5) {\large 8};
		\end{tikzpicture}		
	}
	\subfloat[Dopo]{
		
		\begin{tikzpicture}[scale = 1]
		\draw (0,0) grid (3,3);
		
		\draw[fill = gray, opacity = 0.2]
		(2,2) rectangle (3,3);	
		
		\draw[fill = gray, opacity = 0.2]
		(2,1) rectangle (3,0);	
		
		\node at (1.5, 1.5) {\large 3};
		\node at (0.5, 0.5) {\large 2};
		\node at (1.5, 0.5) {\large 7};
		\node at (0.5, 2.5) {\large 1};
		\node at (0.5, 1.5) {\large 4};
		\node at (2.5, 2.5) {\large \textbf{9}};
		\node at (1.5, 2.5) {\large 5};
		\node at (2.5, 0.5) {\large \textbf{6}};
		\node at (2.5, 1.5) {\large 8};
		\end{tikzpicture}			
	}
	\caption{Esempio di rettificazione lineare. Dopo la rettificazione la prima è l'ultima riga diventano magiche.}
	
\end{figure}

%----------------------------------------------------------------------------------------
%	REFERENCE LIST
%----------------------------------------------------------------------------------------

\begin{thebibliography}{99} 
	
\bibitem{Abe:1994}
Abe, G. (1994).
\newblock Unsolved Problems on Magic Squares.
\newblock {\em Discrete Mathematics (1993) 127 (1–3).}

\bibitem{AhmedEnder:2014}
Ahmed, K. e Ender Ö. (2014).
\newblock Constructing Constrained-Version of Magic Squares Using Selection Hyper-heuristics.
\newblock {\em The Computer Journal (2014) 57 (3)}.

\bibitem{Boyer}
Boyer, C. 
\newblock \url{http://www.multimagie.com}.

\bibitem{Krai:1942}
Kraitchik, M. (1942).
\newblock Mathematical Recreations.
\newblock Norton, New York.

\bibitem{Loly:2003}
Loly, P. (2003).
\newblock Scientific Studies of Magic Squares.
\newblock \url{http://home.cc.umanitoba.ca/~loly/IHPST.pdf}.

\bibitem{Mitchell:1998}
Mitchell, M. (1996).
\newblock An Introduction to Genetic Algorithms.
\newblock MIT Press, Cambridge.

\bibitem{SahaBha:2015}
Saha, B. e Bhattacharya, S (2015).
\newblock An Approach To Hiding Image Into Video  Using Magic Square
\newblock {\em International Conference on Computer Science and Engineering, 2012}.

\bibitem{TombaShiniraj:2014}
Tomba, I. e Shibiraj, N (2014).
\newblock Successful Implementation of the Hill and Magic Square Ciphers: A New Direction.
\newblock {\em International Journal of Advanced Computer Technology }.

\bibitem{Trump}
Trump, W. (2015).
\newblock \url{http://www.trump.de/magic-squares/estimates/index.html}.

\bibitem{XieKang:2003}
Xie, T. e Kang, L. (2003).
\newblock An Evolutionary Algorithm for Magic Squares.
\newblock {\em The 2003 Congress on Evolutionary Computation, 2003}.
 
\end{thebibliography}

%----------------------------------------------------------------------------------------


\onecolumn

\begin{figure}[htbp]
	\centering
	\subfloat[Fitness vs generazione al variare dell'ordine dei quadrati. Dove la fitness è negativa il quadrato è semimagico è si fanno rettificazioni locali diagonali. In questa fase non è rappresentato il nuovo genitore, ma il figlio migliore. Questo mostra come sia esplorato lo spazio delle soluzioni. ]{
		\includegraphics[width=0.9\columnwidth,keepaspectratio=true]{fitvsgen}
		\label{fig:fitvsgen}
		}
	
	\centering
	\subfloat[Linee non magiche vs generazione al variare dell'ordine dei quadrati. ]{\includegraphics[width=0.9\columnwidth,keepaspectratio=true]{incvsgen}}
	\caption{Statistiche al variare dell'ordine del quadrato: blu 10, giallo 15, verde 20, rosso 25, viola 30.}
\end{figure}

\begin{figure}[htbp]
	\centering
	\includegraphics[keepaspectratio=true, height=\textheight]{flowchart}
	\caption{Diagramma di flusso dell'algoritmo di Xie e Kang.}
	\label{fig:flowchart}
\end{figure}

\end{document}


%%% Local Variables:
%%% ispell-local-dictionary: "italiano"
%%% End: